{
  "layout": "blog",
  "language": "en",
  "date": "2024-01-12T07:51:43.682Z",
  "body": "Element implicitly has an 'any' type because expression of type 'string' can't be used to index type. What does this even mean and how to fix it?\n\nBobby writes in more detail about this issue on his blog:\n<https://bobbyhadz.com/blog/typescript-element-implicitly-has-any-type-expression>\n\nTypeScript is basically telling us that the `string` type is too broad for it's liking because not all potential strings in the object are necessarely keys â€” so we have to convince it otherwise; that this is, indeed, one of the object's keys.\n\n```\nconst customerInfo = {\n  first_name: { ... }\n  last_name: { ... }\n  ...\n}\n\nconst contactForm = {\n  first_name: {\n    label: \"First name\",\n    value: null\n  }\n}\n\nObject.entries(contactForm).forEach((props, key) => {\n  if (props.value === null) {\n    const storedValue = customerInfo[key as keyof typeof customerInfo]\n  }\n}\n```\n\nThe secret sauce is telling Typescript that the index (key) indeed is one of whatever keys the obj contains by using the `typeof keyof` type assertion.",
  "title": "Use obj[variable] without Typescript causing an issue with \"type assertion\""
}