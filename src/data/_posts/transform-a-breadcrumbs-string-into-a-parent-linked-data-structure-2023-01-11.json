{
  "layout": "blog",
  "language": "en",
  "date": "2023-01-11T14:00:11.433Z",
  "title": "Transform a breadcrumbs-string into a parent-linked data structure",
  "body": "Create a hierarchy of child/parent-menu items from a string of breadcrumbs using Map().\n\nI scraped breadcrumbs of a e-commerce site, to use as a menu-template for my own e-commerce project, and got a list of strings like this:\n\n```\nconst scrapedCategories = [\n\"Möbler\",\n\"Möbler - Förvaring\",\n\"Möbler - Belysning\",\n\"Möbler - Belysning - Bordlampor\",\n\"Möbler - Belysning - Taklampor\",\n\"Möbler - Belysning - Utebelysning\",\n\"Möbler - Hallmöbler\",\n\"Möbler - Hallmöbler - Byråer\",\n\"Möbler - Hallmöbler - Bänkar\",\n]\n```\n\nMy goal was to have an array with all individual menus containing their name and their parent. If they did not have a parent; contain null.\n\n```\n// My goal:\n\nconst finalVersion = [\n  {\n    \"menu\": \"Möbler\",\n    \"parent\": null\n  },\n  {\n    \"menu\": \"Belysning\",\n    \"parent\": \"Möbler\"\n  },\n  {\n    \"menu\": \"Bordlampor\",\n    \"parent\": \"Belysning\"\n  }\n]\n```\n\nFirst step is to split the initial strings into an array of individual elements. I reverse the array so that I get the deepest sub-category first in line, which will help in the next step with recursion.\n\n```\nconst stringToArray = scrapedCategories.map(string => {\n  return string\n    .split(\" - \")\n    .reverse()\n})\n```\n\nRecursion is used to to re-call the same function until JavaScript stumbles across your stop condition. It fits in my part-goal to chain a sub-category to it's parent, regardless of levels nested.\n\n```\nfunction chainToParent(array) {\n  if (!array.length) return null\n  \n  return {\n    menu: array.at(0),\n    parent: chainToParent(array.splice(1))\n  }\n}\n```\n\nThe function above will transform an array into an object of two properties. \n\n* Menu-property containing the first element of the array.\n* Parent-property containing an object holding two properties (menu and parent).\n\nThe parent property is created by using recursion with the goal to recreate a copy of the top-level logic - continuing until it hits the stop condition. \n\n```\nconst arrayToList = chainToParent([\"Bordlampor\", \"Belysning\", \"Möbler\"])\n\n// result = {\n  menu: 'Bordlampor',\n  parent: {\n    menu: 'Belysning',\n    parent: { \n      menu: 'Möbler', \n      parent: null\n    }\n  }\n}\n```\n\n`Map()` is a great way get flattened results of child<->parent dependency. Using `Map()` and another function with recursion takes us all the way to the goal.\n\n```\nconst listOfMenuParents = new Map()\n\nfunction flatten(node) {\n  if (!node.parent) {\n  return listOfMenuParents.set(node.menu, null)\n}\n  listOfMenuParents.set(node.menu, node.parent.menu)\n  return flatten(node.parent)\n}\n```\n\nExecuting the flatten-function above and reading the Map() gives us the following:\n\n```\narrayToList.forEach(chainedList => {\n  flatten(chainedList)\n}\n\n// Result: {\n  'Möbler' => null,\n  'Belysning' => 'Möbler',\n  'Bordlampor' => 'Belysning',\n}\n```\n\n*This can be written shorter without temprary variables but opted in for a more descriptive (verbose) explanation.*"
}